<html><head>
  <!-- bower:css -->
  <!-- endbower -->
  <style>
  html, body {
    margin: 0;
    padding: 0;
    background-color: black;
  }

  .label {
    position: absolute;
    color: white;
    bottom: 10px;
    left: 10px;
    width: 100%;
    height: 20px;
    font-family: 'Arial';
    font-size: 14px;
  }

  button {
    position: absolute;
    right: 5px;
    top: 5px;
    min-height: 2em;
  }
  </style>
</head>
<body>
  <!-- bower:js -->
  <!-- endbower -->
  <script src="app.js" type="text/javascript"></script>
  <script>
    var rfc = '\n\n\n\n\n\nInternet Engineering Task Force (IETF)                    D. Thaler, Ed.\nRequest for Comments: 6724                                     Microsoft\nObsoletes: 3484                                                R. Draves\nCategory: Standards Track                             Microsoft Research\nISSN: 2070-1721                                             A. Matsumoto\n                                                                     NTT\n                                                                T. Chown\n                                               University of Southampton\n                                                          September 2012\n\n\n    Default Address Selection for Internet Protocol Version 6 (IPv6)\n\nAbstract\n\n   This document describes two algorithms, one for source address\n   selection and one for destination address selection.  The algorithms\n   specify default behavior for all Internet Protocol version 6 (IPv6)\n   implementations.  They do not override choices made by applications\n   or upper-layer protocols, nor do they preclude the development of\n   more advanced mechanisms for address selection.  The two algorithms\n   share a common context, including an optional mechanism for allowing\n   administrators to provide policy that can override the default\n   behavior.  In dual-stack implementations, the destination address\n   selection algorithm can consider both IPv4 and IPv6 addresses --\n   depending on the available source addresses, the algorithm might\n   prefer IPv6 addresses over IPv4 addresses, or vice versa.\n\n   Default address selection as defined in this specification applies to\n   all IPv6 nodes, including both hosts and routers.  This document\n   obsoletes RFC 3484.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in Section 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6724.\n\n\n\n\n\n\nThaler, et al.               Standards Track                    [Page 1]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\nCopyright Notice\n\n   Copyright (c) 2012 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust\'s Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\nTable of Contents\n\n   1. Introduction ....................................................3\n      1.1. Conventions Used in This Document ..........................4\n   2. Context in Which the Algorithms Operate .........................4\n      2.1. Policy Table ...............................................6\n      2.2. Common Prefix Length .......................................7\n   3. Address Properties ..............................................7\n      3.1. Scope Comparisons ..........................................8\n      3.2. IPv4 Addresses and IPv4-Mapped Addresses ...................8\n      3.3. Other IPv6 Addresses with Embedded IPv4 Addresses ..........9\n      3.4. IPv6 Loopback Address and Other Format Prefixes ............9\n      3.5. Mobility Addresses .........................................9\n   4. Candidate Source Addresses .....................................10\n   5. Source Address Selection .......................................11\n   6. Destination Address Selection ..................................14\n   7. Interactions with Routing ......................................16\n   8. Implementation Considerations ..................................16\n   9. Security Considerations ........................................17\n   10. Examples ......................................................18\n      10.1. Default Source Address Selection .........................18\n      10.2. Default Destination Address Selection ....................19\n      10.3. Configuring Preference for IPv6 or IPv4 ..................20\n           10.3.1. Handling Broken IPv6 ..............................21\n      10.4. Configuring Preference for Link-Local Addresses ..........21\n      10.5. Configuring a Multi-Homed Site ...........................22\n      10.6. Configuring ULA Preference ...............................24\n      10.7. Configuring 6to4 Preference ..............................25\n   11. References ....................................................26\n      11.1. Normative References .....................................26\n      11.2. Informative References ...................................27\n   Appendix A.  Acknowledgements .....................................29\n   Appendix B.  Changes since RFC 3484 ...............................29\n\n\n\nThaler, et al.               Standards Track                    [Page 2]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n1.  Introduction\n\n   The IPv6 addressing architecture [RFC4291] allows multiple unicast\n   addresses to be assigned to interfaces.  These addresses might have\n   different reachability scopes (link-local, site-local, or global).\n   These addresses might also be "preferred" or "deprecated" [RFC4862].\n   Privacy considerations have introduced the concepts of "public\n   addresses" and "temporary addresses" [RFC4941].  The mobility\n   architecture introduces "home addresses" and "care-of addresses"\n   [RFC6275].  In addition, multi-homing situations will result in more\n   addresses per node.  For example, a node might have multiple\n   interfaces, some of them tunnels or virtual interfaces, or a site\n   might have multiple ISP attachments with a global prefix per ISP.\n\n   The end result is that IPv6 implementations will very often be faced\n   with multiple possible source and destination addresses when\n   initiating communication.  It is desirable to have default\n   algorithms, common across all implementations, for selecting source\n   and destination addresses so that developers and administrators can\n   reason about and predict the behavior of their systems.\n\n   Furthermore, dual- or hybrid-stack implementations, which support\n   both IPv6 and IPv4, will very often need to choose between IPv6 and\n   IPv4 when initiating communication, for example, when DNS name\n   resolution yields both IPv6 and IPv4 addresses and the network\n   protocol stack has available both IPv6 and IPv4 source addresses.  In\n   such cases, a simple policy to always prefer IPv6 or always prefer\n   IPv4 can produce poor behavior.  As one example, suppose a DNS name\n   resolves to a global IPv6 address and a global IPv4 address.  If the\n   node has assigned a global IPv6 address and a 169.254/16 auto-\n   configured IPv4 address [RFC3927], then IPv6 is the best choice for\n   communication.  But if the node has assigned only a link-local IPv6\n   address and a global IPv4 address, then IPv4 is the best choice for\n   communication.  The destination address selection algorithm solves\n   this with a unified procedure for choosing among both IPv6 and IPv4\n   addresses.\n\n   The algorithms in this document are specified as a set of rules that\n   define a partial ordering on the set of addresses that are available\n   for use.  In the case of source address selection, a node typically\n   has multiple addresses assigned to its interfaces, and the source\n   address ordering rules in Section 5 define which address is the\n   "best" one to use.  In the case of destination address selection, the\n   DNS might return a set of addresses for a given name, and an\n   application needs to decide which one to use first and in what order\n   to try others if the first one is not reachable.  The destination\n   address ordering rules in Section 6, when applied to the set of\n   addresses returned by the DNS, provide such a recommended ordering.\n\n\n\nThaler, et al.               Standards Track                    [Page 3]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   This document specifies source address selection and destination\n   address selection separately but uses a common context so that\n   together the two algorithms yield useful results.  The algorithms\n   attempt to choose source and destination addresses of appropriate\n   scope and configuration status ("preferred" or "deprecated" in the\n   RFC 4862 sense).  Furthermore, this document suggests a preferred\n   method, longest matching prefix, for choosing among otherwise\n   equivalent addresses in the absence of better information.\n\n   This document also specifies policy hooks to allow administrative\n   override of the default behavior.  For example, using these hooks, an\n   administrator can specify a preferred source prefix for use with a\n   destination prefix or prefer destination addresses with one prefix\n   over addresses with another prefix.  These hooks give an\n   administrator flexibility in dealing with some multi-homing and\n   transition scenarios, but they are certainly not a panacea.\n\n   The selection rules specified in this document MUST NOT be construed\n   to override an application or upper layer\'s explicit choice of a\n   legal destination or source address.\n\n1.1.  Conventions Used in This Document\n\n   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",\n   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this\n   document are to be interpreted as described in BCP 14, RFC 2119\n   [RFC2119].\n\n2.  Context in Which the Algorithms Operate\n\n   Our context for address selection derives from the most common\n   implementation architecture, which separates the choice of\n   destination address from the choice of source address.  Consequently,\n   we have two separate algorithms for these tasks.  The algorithms are\n   designed to work well together, and they share a mechanism for\n   administrative policy override.\n\n   In this implementation architecture, applications use APIs such as\n   getaddrinfo() [RFC3493] that return a list of addresses to the\n   application.  This list might contain both IPv6 and IPv4 addresses\n   (sometimes represented as IPv4-mapped addresses).  The application\n   then passes a destination address to the network stack with connect()\n   or sendto().  The application would then typically try the first\n   address in the list, looping over the list of addresses until it\n   finds a working address.  In any case, the network layer is never in\n   a situation where it needs to choose a destination address from\n   several alternatives.  The application might also specify a source\n\n\n\n\nThaler, et al.               Standards Track                    [Page 4]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   address with bind(), but often the source address is left\n   unspecified.  Therefore, the network layer does often choose a source\n   address from several alternatives.\n\n   As a consequence, we intend that implementations of APIs such as\n   getaddrinfo() will use the destination address selection algorithm\n   specified here to sort the list of IPv6 and IPv4 addresses that they\n   return.  Separately, the IPv6 network layer will use the source\n   address selection algorithm when an application or upper layer has\n   not specified a source address.  Application of this specification to\n   source address selection in an IPv4 network layer might be possible,\n   but this is not explored further here.\n\n   Well-behaved applications SHOULD NOT simply use the first address\n   returned from an API such as getaddrinfo() and then give up if it\n   fails.  For many applications, it is appropriate to iterate through\n   the list of addresses returned from getaddrinfo() until a working\n   address is found.  For other applications, it might be appropriate to\n   try multiple addresses in parallel (e.g., with some small delay in\n   between) and use the first one to succeed.\n\n   Although source and destination address selection is most typically\n   done when initiating communication, a responder also must deal with\n   address selection.  In many cases, this is trivially dealt with by an\n   application using the source address of a received packet as the\n   response destination and the destination address of the received\n   packet as the response source.  Other cases, however, are handled\n   like an initiator, such as when the request is multicast and hence\n   source address selection must still occur when generating a response\n   or when the request includes a list of the initiator\'s addresses from\n   which to choose a destination.  Finally, a third application scenario\n   is that of a listening application choosing on what local addresses\n   to listen.  This third scenario is out of the scope of this document.\n\n   The algorithms use several criteria in making their decisions.  The\n   combined effect is to prefer destination/source address pairs for\n   which the two addresses are of equal scope or type, prefer smaller\n   scopes over larger scopes for the destination address, prefer non-\n   deprecated source addresses, avoid the use of transitional addresses\n   when native addresses are available, and all else being equal, prefer\n   address pairs having the longest possible common prefix.  For source\n   address selection, temporary addresses [RFC4941] are preferred over\n   public addresses.  In mobile situations [RFC6275], home addresses are\n   preferred over care-of addresses.  If an address is simultaneously a\n   home address and a care-of address (indicating the mobile node is "at\n   home" for that address), then the home/care-of address is preferred\n   over addresses that are solely a home address or solely a care-of\n   address.\n\n\n\nThaler, et al.               Standards Track                    [Page 5]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   This specification optionally allows for the possibility of\n   administrative configuration of policy (e.g., via manual\n   configuration or a DHCP option such as that proposed in\n   [ADDR-SEL-OPT]) that can override the default behavior of the\n   algorithms.  The policy override consists of the following set of\n   state, which SHOULD be configurable:\n\n   o  Policy Table (Section 2.1): a table that specifies precedence\n      values and preferred source prefixes for destination prefixes.\n\n   o  Automatic Row Additions flag (Section 2.1): a flag that specifies\n      whether the implementation is permitted to automatically add site-\n      specific rows for certain types of addresses.\n\n   o  Privacy Preference flag (Section 5): a flag that specifies whether\n      temporary source addresses or stable source addresses are\n      preferred by default when both types exist.\n\n2.1.  Policy Table\n\n   The policy table is a longest-matching-prefix lookup table, much like\n   a routing table.  Given an address A, a lookup in the policy table\n   produces two values: a precedence value denoted Precedence(A) and a\n   classification or label denoted Label(A).\n\n   The precedence value Precedence(A) is used for sorting destination\n   addresses.  If Precedence(A) > Precedence(B), we say that address A\n   has higher precedence than address B, meaning that our algorithm will\n   prefer to sort destination address A before destination address B.\n\n   The label value Label(A) allows for policies that prefer a particular\n   source address prefix for use with a destination address prefix.  The\n   algorithms prefer to use a source address S with a destination\n   address D if Label(S) = Label(D).\n\n   IPv6 implementations SHOULD support configurable address selection\n   via a mechanism at least as powerful as the policy tables defined\n   here.  It is important that implementations provide a way to change\n   the default policies as more experience is gained.  Sections 10.3\n   through 10.7 provide examples of the kind of changes that might be\n   needed.\n\n   If an implementation is not configurable or has not been configured,\n   then it SHOULD operate according to the algorithms specified here in\n   conjunction with the following default policy table:\n\n\n\n\n\n\nThaler, et al.               Standards Track                    [Page 6]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      ::/0                  40     1\n      ::ffff:0:0/96         35     4\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n   An implementation MAY automatically add additional site-specific rows\n   to the default table based on its configured addresses, such as for\n   Unique Local Addresses (ULAs) [RFC4193] and 6to4 [RFC3056] addresses,\n   for instance (see Sections 10.6 and 10.7 for examples).  Any such\n   rows automatically added by the implementation as a result of address\n   acquisition MUST NOT override a row for the same prefix configured\n   via other means.  That is, rows can be added but never updated\n   automatically.  An implementation SHOULD provide a means (the\n   Automatic Row Additions flag) for an administrator to disable\n   automatic row additions.\n\n   As will become apparent later, one effect of the default policy table\n   is to prefer using native source addresses with native destination\n   addresses, 6to4 source addresses with 6to4 destination addresses,\n   etc.  Another effect of the default policy table is to prefer\n   communication using IPv6 addresses to communication using IPv4\n   addresses, if matching source addresses are available.\n\n   Policy table entries for address prefixes that are not of global\n   scope MAY be qualified with an optional zone index.  If so, a prefix\n   table entry only matches against an address during a lookup if the\n   zone index also matches the address\'s zone index.\n\n2.2.  Common Prefix Length\n\n   We define the common prefix length CommonPrefixLen(S, D) of a source\n   address S and a destination address D as the length of the longest\n   prefix (looking at the most significant, or leftmost, bits) that the\n   two addresses have in common, up to the length of S\'s prefix (i.e.,\n   the portion of the address not including the interface ID).  For\n   example, CommonPrefixLen(fe80::1, fe80::2) is 64.\n\n3.  Address Properties\n\n   In the rules given in later sections, addresses of different types\n   (e.g., IPv4, IPv6, multicast, and unicast) are compared against each\n   other.  Some of these address types have properties that aren\'t\n\n\n\nThaler, et al.               Standards Track                    [Page 7]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   directly comparable to each other.  For example, IPv6 unicast\n   addresses can be "preferred" or "deprecated" [RFC4862], while IPv4\n   addresses have no such notion.  To compare such addresses using the\n   ordering rules (e.g., to use "preferred" addresses in preference to\n   "deprecated" addresses), the following mappings are defined.\n\n3.1.  Scope Comparisons\n\n   Multicast destination addresses have a 4-bit scope field that\n   controls the propagation of the multicast packet.  The IPv6\n   addressing architecture defines scope field values for interface-\n   local (0x1), link-local (0x2), admin-local (0x4), site-local (0x5),\n   organization-local (0x8), and global (0xE) scopes (Section 2.7 of\n   [RFC4291]).\n\n   Use of the source address selection algorithm in the presence of\n   multicast destination addresses requires the comparison of a unicast\n   address scope with a multicast address scope.  We map unicast link-\n   local to multicast link-local, unicast site-local to multicast site-\n   local, and unicast global scope to multicast global scope.  For\n   example, unicast site-local is equal to multicast site-local, which\n   is smaller than multicast organization-local, which is smaller than\n   unicast global, which is equal to multicast global.  (Note that IPv6\n   site-local unicast addresses are deprecated [RFC4291].  However, some\n   existing implementations and deployments may still use these\n   addresses; they are therefore included in the procedures in this\n   specification.  Also, note that ULAs are considered as global, not\n   site-local, scope but are handled via the prefix policy table as\n   discussed in Section 10.6.)\n\n   We write Scope(A) to mean the scope of address A.  For example, if A\n   is a link-local unicast address and B is a site-local multicast\n   address, then Scope(A) < Scope(B).\n\n   This mapping implicitly conflates unicast site boundaries and\n   multicast site boundaries [RFC4007].\n\n3.2.  IPv4 Addresses and IPv4-Mapped Addresses\n\n   The destination address selection algorithm operates on both IPv6 and\n   IPv4 addresses.  For this purpose, IPv4 addresses MUST be represented\n   as IPv4-mapped addresses [RFC4291].  For example, to look up the\n   precedence or other attributes of an IPv4 address in the policy\n   table, look up the corresponding IPv4-mapped IPv6 address.\n\n   IPv4 addresses are assigned scopes as follows.  IPv4 auto-\n   configuration addresses [RFC3927], which have the prefix 169.254/16,\n   are assigned link-local scope.  IPv4 loopback addresses (Section\n\n\n\nThaler, et al.               Standards Track                    [Page 8]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   4.2.2.11 of [RFC1812]), which have the prefix 127/8, are assigned\n   link-local scope (analogously to the treatment of the IPv6 loopback\n   address (Section 4 of [RFC4007])).  Other IPv4 addresses (including\n   IPv4 private addresses [RFC1918] and Shared Address Space addresses\n   [RFC6598]) are assigned global scope.\n\n   IPv4 addresses MUST be treated as having "preferred" (in the RFC 4862\n   sense) configuration status.\n\n3.3.  Other IPv6 Addresses with Embedded IPv4 Addresses\n\n   IPv4-compatible addresses [RFC4291], IPv4-mapped [RFC4291], IPv4-\n   converted [RFC6145], IPv4-translatable [RFC6145], and 6to4 addresses\n   [RFC3056] contain an embedded IPv4 address.  For the purposes of this\n   document, these addresses MUST be treated as having global scope.\n\n   IPv4-compatible, IPv4-mapped, and IPv4-converted addresses MUST be\n   treated as having "preferred" (in the RFC 4862 sense) configuration\n   status.\n\n3.4.  IPv6 Loopback Address and Other Format Prefixes\n\n   The loopback address MUST be treated as having link-local scope\n   (Section 4 of [RFC4007]) and "preferred" (in the RFC 4862 sense)\n   configuration status.\n\n   NSAP addresses and other addresses with as-yet-undefined format\n   prefixes MUST be treated as having global scope and "preferred" (in\n   the RFC 4862) configuration status.  Later standards might supersede\n   this treatment.\n\n3.5.  Mobility Addresses\n\n   Some nodes might support mobility using the concepts of home address\n   and care-of address (for example, see [RFC6275]).  Conceptually, a\n   home address is an IP address assigned to a mobile node and used as\n   the permanent address of the mobile node.  A care-of address is an IP\n   address associated with a mobile node while visiting a foreign link.\n   When a mobile node is on its home link, it might have an address that\n   is simultaneously a home address and a care-of address.\n\n   For the purposes of this document, it is sufficient to know whether\n   one\'s own addresses are designated as home addresses or care-of\n   addresses.  Whether an address ought to be designated a home address\n   or care-of address is outside the scope of this document.\n\n\n\n\n\n\nThaler, et al.               Standards Track                    [Page 9]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n4.  Candidate Source Addresses\n\n   The source address selection algorithm uses the concept of a\n   "candidate set" of potential source addresses for a given destination\n   address.  The candidate set is the set of all addresses that could be\n   used as a source address; the source address selection algorithm will\n   pick an address out of that set.  We write CandidateSource(A) to\n   denote the candidate set for the address A.\n\n   It is RECOMMENDED that the candidate source addresses be the set of\n   unicast addresses assigned to the interface that will be used to send\n   to the destination (the "outgoing" interface).  On routers, the\n   candidate set MAY include unicast addresses assigned to any interface\n   that forwards packets, subject to the restrictions described below.\n   Implementations that wish to support the use of global source\n   addresses assigned to a loopback interface MUST behave as if the\n   loopback interface originates and forwards the packet.\n\n      Discussion: The Neighbor Discovery Redirect mechanism [RFC4861]\n      requires that routers verify that the source address of a packet\n      identifies a neighbor before generating a Redirect, so it is\n      advantageous for hosts to choose source addresses assigned to the\n      outgoing interface.\n\n   In some cases, the destination address might be qualified with a zone\n   index or other information that will constrain the candidate set.\n\n   For all multicast and link-local destination addresses, the set of\n   candidate source addresses MUST only include addresses assigned to\n   interfaces belonging to the same link as the outgoing interface.\n\n      Discussion: The restriction for multicast destination addresses is\n      necessary because currently deployed multicast forwarding\n      algorithms use Reverse Path Forwarding (RPF) checks.\n\n   For site-local unicast destination addresses, the set of candidate\n   source addresses MUST only include addresses assigned to interfaces\n   belonging to the same site as the outgoing interface.\n\n   In any case, multicast addresses and the unspecified address MUST NOT\n   be included in a candidate set.\n\n   On IPv6-only nodes that support Stateless IP/ICMP Translation (SIIT)\n   [RFC6145], if the destination address is an IPv4-converted address,\n   then the candidate set MUST contain only IPv4-translatable addresses.\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 10]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   If an application or upper layer specifies a source address, it may\n   affect the choice of outgoing interface.  Regardless, if the\n   application or upper layer specifies a source address that is not in\n   the candidate set for the destination, then the network layer MUST\n   treat this as an error.  If the application or upper layer specifies\n   a source address that is in the candidate set for the destination,\n   then the network layer MUST respect that choice.  If the application\n   or upper layer does not specify a source address, then the network\n   layer uses the source address selection algorithm specified in the\n   next section.\n\n5.  Source Address Selection\n\n   The source address selection algorithm produces as output a single\n   source address for use with a given destination address.  This\n   algorithm only applies to IPv6 destination addresses, not IPv4\n   addresses.\n\n   The algorithm is specified here in terms of a list of pair-wise\n   comparison rules that (for a given destination address D) imposes a\n   "greater than" ordering on the addresses in the candidate set\n   CandidateSource(D).  The address at the front of the list after the\n   algorithm completes is the one the algorithm selects.\n\n   Note that conceptually, a sort of the candidate set is being\n   performed, where a set of rules define the ordering among addresses.\n   But because the output of the algorithm is a single source address,\n   an implementation need not actually sort the set; it need only\n   identify the "maximum" value that ends up at the front of the sorted\n   list.\n\n   The ordering of the addresses in the candidate set is defined by a\n   list of eight pair-wise comparison rules, with each rule placing a\n   "greater than", "less than", or "equal to" ordering on two source\n   addresses with respect to each other (and that rule).  In the case\n   that a given rule produces a tie, i.e., provides an "equal to" result\n   for the two addresses, the remaining rules MUST be applied (in order)\n   to just those addresses that are tied to break the tie.  Note that if\n   a rule produces a single clear "winner" (or set of "winners" in the\n   case of ties), those addresses not in the winning set can be\n   discarded from further consideration, with subsequent rules applied\n   only to the remaining addresses.  If the eight rules fail to choose a\n   single address, the tiebreaker is implementation-specific.\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 11]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   When comparing two addresses SA and SB from the candidate set, we say\n   "prefer SA" to mean that SA is "greater than" SB, and similarly, we\n   say "prefer SB" to mean that SA is "less than" SB.  If neither is\n   stated to be preferred, this means that SA is "equal to" SB, and the\n   remaining rules apply as noted above.\n\n   Rule 1: Prefer same address.\n   If SA = D, then prefer SA.  Similarly, if SB = D, then prefer SB.\n\n   Rule 2: Prefer appropriate scope.\n   If Scope(SA) < Scope(SB): If Scope(SA) < Scope(D), then prefer SB and\n   otherwise prefer SA.  Similarly, if Scope(SB) < Scope(SA): If\n   Scope(SB) < Scope(D), then prefer SA and otherwise prefer SB.\n\n      Discussion: This rule must be given high priority because it can\n      affect interoperability.\n\n   Rule 3: Avoid deprecated addresses.\n   If one of the two source addresses is "preferred" and one of them is\n   "deprecated" (in the RFC 4862 sense), then prefer the one that is\n   "preferred".\n\n   Rule 4: Prefer home addresses.\n   If SA is simultaneously a home address and care-of address and SB is\n   not, then prefer SA.  Similarly, if SB is simultaneously a home\n   address and care-of address and SA is not, then prefer SB.  If SA is\n   just a home address and SB is just a care-of address, then prefer SA.\n   Similarly, if SB is just a home address and SA is just a care-of\n   address, then prefer SB.\n\n   Implementations supporting home addresses MUST provide a mechanism\n   allowing an application to reverse the sense of this preference and\n   prefer care-of addresses over home addresses (e.g., via appropriate\n   API extensions such as [RFC5014]).  Use of the mechanism MUST only\n   affect the selection rules for the invoking application.\n\n   Rule 5: Prefer outgoing interface.\n   If SA is assigned to the interface that will be used to send to D and\n   SB is assigned to a different interface, then prefer SA.  Similarly,\n   if SB is assigned to the interface that will be used to send to D and\n   SA is assigned to a different interface, then prefer SB.\n\n   Rule 5.5: Prefer addresses in a prefix advertised by the next-hop.\n   If SA or SA\'s prefix is assigned by the selected next-hop that will\n   be used to send to D and SB or SB\'s prefix is assigned by a different\n   next-hop, then prefer SA.  Similarly, if SB or SB\'s prefix is\n   assigned by the next-hop that will be used to send to D and SA or\n   SA\'s prefix is assigned by a different next-hop, then prefer SB.\n\n\n\nThaler, et al.               Standards Track                   [Page 12]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n      Discussion: An IPv6 implementation is not required to remember\n      which next-hops advertised which prefixes.  The conceptual models\n      of IPv6 hosts in Section 5 of [RFC4861] and Section 3 of [RFC4191]\n      have no such requirement.  Hence, Rule 5.5 is only applicable to\n      implementations that track this information.\n\n   Rule 6: Prefer matching label.\n   If Label(SA) = Label(D) and Label(SB) <> Label(D), then prefer SA.\n   Similarly, if Label(SB) = Label(D) and Label(SA) <> Label(D), then\n   prefer SB.\n\n   Rule 7: Prefer temporary addresses.\n   If SA is a temporary address and SB is a public address, then prefer\n   SA.  Similarly, if SB is a temporary address and SA is a public\n   address, then prefer SB.\n\n   Implementations MUST provide a mechanism allowing an application to\n   reverse the sense of this preference and prefer public addresses over\n   temporary addresses (e.g., via appropriate API extensions such as\n   [RFC5014]).  Use of the mechanism MUST only affect the selection\n   rules for the invoking application.  This default is intended to\n   address privacy concerns as discussed in [RFC4941] but introduces a\n   risk of applications potentially failing due to the relatively short\n   lifetime of temporary addresses or due to the possibility of the\n   reverse lookup of a temporary address either failing or returning a\n   randomized name.  Implementations for which application compatibility\n   considerations outweigh these privacy concerns MAY reverse the sense\n   of this rule and by default prefer public addresses over temporary\n   addresses.  There SHOULD be an administrative option (the Privacy\n   Preference flag) to change this preference, if the implementation\n   supports temporary addresses.  If there is no such option, there MUST\n   be an administrative option to disable temporary addresses.\n\n   Rule 8: Use longest matching prefix.\n   If CommonPrefixLen(SA, D) > CommonPrefixLen(SB, D), then prefer SA.\n   Similarly, if CommonPrefixLen(SB, D) > CommonPrefixLen(SA, D), then\n   prefer SB.\n\n   Rule 8 MAY be superseded if the implementation has other means of\n   choosing among source addresses.  For example, if the implementation\n   somehow knows which source address will result in the "best"\n   communications performance.\n\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 13]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n6.  Destination Address Selection\n\n   The destination address selection algorithm takes a list of\n   destination addresses and sorts the addresses to produce a new list.\n   It is specified here in terms of the pair-wise comparison of\n   addresses DA and DB, where DA appears before DB in the original list.\n\n   The algorithm sorts together both IPv6 and IPv4 addresses.  To find\n   the attributes of an IPv4 address in the policy table, the IPv4\n   address MUST be represented as an IPv4-mapped address.\n\n   We write Source(D) to indicate the selected source address for a\n   destination D.  For IPv6 addresses, the previous section specifies\n   the source address selection algorithm.  Source address selection for\n   IPv4 addresses is not specified in this document.\n\n   We say that Source(D) is undefined if there is no source address\n   available for destination D.  For IPv6 addresses, this is only the\n   case if CandidateSource(D) is the empty set.\n\n   The pair-wise comparison of destination addresses consists of ten\n   rules, which MUST be applied in order.  If a rule determines a\n   result, then the remaining rules are not relevant and MUST be\n   ignored.  Subsequent rules act as tiebreakers for earlier rules.  See\n   the previous section for a lengthier description of how pair-wise\n   comparison tiebreaker rules can be used to sort a list.\n\n   Rule 1: Avoid unusable destinations.\n   If DB is known to be unreachable or if Source(DB) is undefined, then\n   prefer DA.  Similarly, if DA is known to be unreachable or if\n   Source(DA) is undefined, then prefer DB.\n\n      Discussion: An implementation might know that a particular\n      destination is unreachable in several ways.  For example, the\n      destination might be reached through a network interface that is\n      currently unplugged.  For example, the implementation might retain\n      information from Neighbor Unreachability Detection [RFC4861] for\n      some period of time.  In any case, the determination of\n      unreachability for the purposes of this rule is implementation-\n      dependent.\n\n   Rule 2: Prefer matching scope.\n   If Scope(DA) = Scope(Source(DA)) and Scope(DB) <> Scope(Source(DB)),\n   then prefer DA.  Similarly, if Scope(DA) <> Scope(Source(DA)) and\n   Scope(DB) = Scope(Source(DB)), then prefer DB.\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 14]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Rule 3: Avoid deprecated addresses.\n   If Source(DA) is deprecated and Source(DB) is not, then prefer DB.\n   Similarly, if Source(DA) is not deprecated and Source(DB) is\n   deprecated, then prefer DA.\n\n   Rule 4: Prefer home addresses.\n   If Source(DA) is simultaneously a home address and care-of address\n   and Source(DB) is not, then prefer DA.  Similarly, if Source(DB) is\n   simultaneously a home address and care-of address and Source(DA) is\n   not, then prefer DB.\n\n   If Source(DA) is just a home address and Source(DB) is just a care-of\n   address, then prefer DA.  Similarly, if Source(DA) is just a care-of\n   address and Source(DB) is just a home address, then prefer DB.\n\n   Rule 5: Prefer matching label.\n   If Label(Source(DA)) = Label(DA) and Label(Source(DB)) <> Label(DB),\n   then prefer DA.  Similarly, if Label(Source(DA)) <> Label(DA) and\n   Label(Source(DB)) = Label(DB), then prefer DB.\n\n   Rule 6: Prefer higher precedence.\n   If Precedence(DA) > Precedence(DB), then prefer DA.  Similarly, if\n   Precedence(DA) < Precedence(DB), then prefer DB.\n\n   Rule 7: Prefer native transport.\n   If DA is reached via an encapsulating transition mechanism (e.g.,\n   IPv6 in IPv4) and DB is not, then prefer DB.  Similarly, if DB is\n   reached via encapsulation and DA is not, then prefer DA.\n\n      Discussion: The IPv6 Rapid Deployment on IPv4 Infrastructures\n      (6rd) Protocol [RFC5969], the Intra-Site Automatic Tunnel\n      Addressing Protocol (ISATAP) [RFC5214], and configured tunnels\n      [RFC4213] are examples of encapsulating transition mechanisms for\n      which the destination address does not have a specific prefix and\n      hence can not be assigned a lower precedence in the policy table.\n      An implementation MAY generalize this rule by using a concept of\n      interface preference and giving virtual interfaces (like the IPv6-\n      in-IPv4 encapsulating interfaces) a lower preference than native\n      interfaces (like ethernet interfaces).\n\n   Rule 8: Prefer smaller scope.\n   If Scope(DA) < Scope(DB), then prefer DA.  Similarly, if Scope(DA) >\n   Scope(DB), then prefer DB.\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 15]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Rule 9: Use longest matching prefix.\n   When DA and DB belong to the same address family (both are IPv6 or\n   both are IPv4): If CommonPrefixLen(Source(DA), DA) >\n   CommonPrefixLen(Source(DB), DB), then prefer DA.  Similarly, if\n   CommonPrefixLen(Source(DA), DA) < CommonPrefixLen(Source(DB), DB),\n   then prefer DB.\n\n   Rule 10: Otherwise, leave the order unchanged.\n   If DA preceded DB in the original list, prefer DA.  Otherwise, prefer\n   DB.\n\n   Rules 9 and 10 MAY be superseded if the implementation has other\n   means of sorting destination addresses.  For example, if the\n   implementation somehow knows which destination addresses will result\n   in the "best" communications performance.\n\n7.  Interactions with Routing\n\n   This specification of source address selection assumes that routing\n   (more precisely, selecting an outgoing interface on a node with\n   multiple interfaces) is done before source address selection.\n   However, implementations MAY use source address considerations as a\n   tiebreaker when choosing among otherwise equivalent routes.\n\n   For example, suppose a node has interfaces on two different links,\n   with both links having a working default router.  Both of the\n   interfaces have preferred (in the RFC 4862 sense) global addresses.\n   When sending to a global destination address, if there\'s no routing\n   reason to prefer one interface over the other, then an implementation\n   MAY preferentially choose the outgoing interface that will allow it\n   to use the source address that shares a longer common prefix with the\n   destination.\n\n   Implementations that support Rule 5.5 of source address selection\n   (Section 5) also use the choice of router to influence the choice of\n   source address.  For example, suppose a host is on a link with two\n   routers.  One router is advertising a global prefix A and the other\n   router is advertising global prefix B.  Then, when sending via the\n   first router, the host might prefer source addresses with prefix A\n   and when sending via the second router, prefer source addresses with\n   prefix B.\n\n8.  Implementation Considerations\n\n   The destination address selection algorithm needs information about\n   potential source addresses.  One possible implementation strategy is\n   for getaddrinfo() to call down to the network layer with a list of\n   destination addresses, sort the list in the network layer with full\n\n\n\nThaler, et al.               Standards Track                   [Page 16]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   current knowledge of available source addresses, and return the\n   sorted list to getaddrinfo().  This is simple and gives the best\n   results, but it introduces the overhead of another system call.  One\n   way to reduce this overhead is to cache the sorted address list in\n   the resolver, so that subsequent calls for the same name do not need\n   to re-sort the list.\n\n   Another implementation strategy is to call down to the network layer\n   to retrieve source address information and then sort the list of\n   addresses directly in the context of getaddrinfo().  To reduce\n   overhead in this approach, the source address information can be\n   cached, amortizing the overhead of retrieving it across multiple\n   calls to getaddrinfo().  In this approach, the implementation might\n   not have knowledge of the outgoing interface for each destination, so\n   it MAY use a looser definition of the candidate set during\n   destination address ordering.\n\n   In any case, if the implementation uses cached and possibly stale\n   information in its implementation of destination address selection or\n   if the ordering of a cached list of destination addresses is possibly\n   stale, then it MUST ensure that the destination address ordering\n   returned to the application is no more than one second out of date.\n   For example, an implementation might make a system call to check if\n   any routing table entries, source address assignments, or prefix\n   policy table entries that might affect these algorithms have changed.\n   Another strategy is to use an invalidation counter that is\n   incremented whenever any underlying state is changed.  By caching the\n   current invalidation counter value with derived state and then later\n   comparing against the current value, the implementation could detect\n   if the derived state is potentially stale.\n\n9.  Security Considerations\n\n   This document has no direct impact on Internet infrastructure\n   security.\n\n   Note that most source address selection algorithms, including the one\n   specified in this document, expose a potential privacy concern.  An\n   unfriendly node can infer correlations among a target node\'s\n   addresses by probing the target node with request packets that force\n   the target host to choose its source address for the reply packets\n   (perhaps because the request packets are sent to an anycast or\n   multicast address or perhaps because the upper-layer protocol chosen\n   for the attack does not specify a particular source address for its\n   reply packets).  By using different addresses for itself, the\n   unfriendly node can cause the target node to expose the target\'s own\n   addresses.  The source address selection default preference for\n   temporary addresses helps mitigate this concern.\n\n\n\nThaler, et al.               Standards Track                   [Page 17]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Similarly, most source and destination address selection algorithms,\n   including the one specified in this document, influence the choice of\n   network path taken (as do routing algorithms that are orthogonal to,\n   but used together with, such algorithms) and hence whether data might\n   be sent over a path or network that might be more or less trusted\n   than other paths or networks.  Administrators should consider the\n   security impact of the rows they configure in the prefix policy\n   table, just as they should consider the security impact of the\n   interface metrics used in the routing algorithms.\n\n   In addition, some address selection rules might be administratively\n   configurable.  Care must be taken to make sure that all\n   administrative options are secured against illicit modification, or\n   else an attacker could redirect and/or block traffic.\n\n10.  Examples\n\n   This section contains a number of examples, first showing default\n   behavior and then demonstrating the utility of policy table\n   configuration.  These examples are provided for illustrative\n   purposes; they are not to be construed as normative.\n\n10.1.  Default Source Address Selection\n\n   The source address selection rules, in conjunction with the default\n   policy table, produce the following behavior:\n\n   Destination: 2001:db8:1::1\n   Candidate Source Addresses: 2001:db8:3::1 or fe80::1\n   Result: 2001:db8::1 (prefer appropriate scope)\n\n   Destination: ff05::1\n   Candidate Source Addresses: 2001:db8:3::1 or fe80::1\n   Result: 2001:db8:3::1 (prefer appropriate scope)\n\n   Destination: 2001:db8:1::1\n   Candidate Source Addresses: 2001:db8:1::1 (deprecated) or\n   2001:db8:2::1\n   Result: 2001:db8:1::1 (prefer same address)\n\n   Destination: fe80::1\n   Candidate Source Addresses: fe80::2 (deprecated) or 2001:db8:1::1\n   Result: fe80::2 (prefer appropriate scope)\n\n   Destination: 2001:db8:1::1\n   Candidate Source Addresses: 2001:db8:1::2 or 2001:db8:3::2\n   Result: 2001:db8:1:::2 (longest matching prefix)\n\n\n\n\nThaler, et al.               Standards Track                   [Page 18]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Destination: 2001:db8:1::1\n   Candidate Source Addresses: 2001:db8:1::2 (care-of address) or 2001:\n   db8:3::2 (home address)\n   Result: 2001:db8:3::2 (prefer home address)\n\n   Destination: 2002:c633:6401::1\n   Candidate Source Addresses: 2002:c633:6401::d5e3:7953:13eb:22e8\n   (temporary) or 2001:db8:1::2\n   Result: 2002:c633:6401::d5e3:7953:13eb:22e8 (prefer matching label)\n\n   Destination: 2001:db8:1::d5e3:0:0:1\n   Candidate Source Addresses: 2001:db8:1::2 (public) or\n   2001:db8:1::d5e3:7953:13eb:22e8 (temporary)\n   Result: 2001:db8:1::d5e3:7953:13eb:22e8 (prefer temporary address)\n\n10.2.  Default Destination Address Selection\n\n   The destination address selection rules, in conjunction with the\n   default policy table and the source address selection rules, produce\n   the following behavior:\n\n   Candidate Source Addresses: 2001:db8:1::2 or fe80::1 or 169.254.13.78\n   Destination Address List: 2001:db8:1::1 or 198.51.100.121\n   Result: 2001:db8:1::1 (src 2001:db8:1::2) then 198.51.100.121 (src\n   169.254.13.78) (prefer matching scope)\n\n   Candidate Source Addresses: fe80::1 or 198.51.100.117\n   Destination Address List: 2001:db8:1::1 or 198.51.100.121\n   Result: 198.51.100.121 (src 198.51.100.117) then 2001:db8:1::1 (src\n   fe80::1) (prefer matching scope)\n\n   Candidate Source Addresses: 2001:db8:1::2 or fe80::1 or 10.1.2.4\n   Destination Address List: 2001:db8:1::1 or 10.1.2.3\n   Result: 2001:db8:1::1 (src 2001:db8:1::2) then 10.1.2.3 (src\n   10.1.2.4) (prefer higher precedence)\n\n   Candidate Source Addresses: 2001:db8:1::2 or fe80::2\n   Destination Address List: 2001:db8:1::1 or fe80::1\n   Result: fe80::1 (src fe80::2) then 2001:db8:1::1 (src 2001:db8:1::2)\n   (prefer smaller scope)\n\n   Candidate Source Addresses: 2001:db8:1::2 (care-of address) or 2001:\n   db8:3::1 (home address) or fe80::2 (care-of address)\n   Destination Address List: 2001:db8:1::1 or fe80::1\n   Result: 2001:db8:1::1 (src 2001:db8:3::1) then fe80::1 (src fe80::2)\n   (prefer home address)\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 19]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Candidate Source Addresses: 2001:db8:1::2 or fe80::2 (deprecated)\n   Destination Address List: 2001:db8:1::1 or fe80::1\n   Result: 2001:db8:1::1 (src 2001:db8:1::2) then fe80::1 (src fe80::2)\n   (avoid deprecated addresses)\n\n   Candidate Source Addresses: 2001:db8:1::2 or 2001:db8:3f44::2 or\n   fe80::2\n   Destination Address List: 2001:db8:1::1 or 2001:db8:3ffe::1\n   Result: 2001:db8:1::1 (src 2001:db8:1::2) then 2001:db8:3ffe::1 (src\n   2001:db8:3f44::2) (longest matching prefix)\n\n   Candidate Source Addresses: 2002:c633:6401::2 or fe80::2\n   Destination Address List: 2002:c633:6401::1 or 2001:db8:1::1\n   Result: 2002:c633:6401::1 (src 2002:c633:6401::2) then 2001:db8:1::1\n   (src 2002:c633:6401::2) (prefer matching label)\n\n   Candidate Source Addresses: 2002:c633:6401::2 or 2001:db8:1::2 or\n   fe80::2\n   Destination Address List: 2002:c633:6401::1 or 2001:db8:1::1\n   Result: 2001:db8:1::1 (src 2001:db8:1::2) then 2002:c633:6401::1 (src\n   2002:c633:6401::2) (prefer higher precedence)\n\n10.3.  Configuring Preference for IPv6 or IPv4\n\n   The default policy table gives IPv6 addresses higher precedence than\n   IPv4 addresses.  This means that applications will use IPv6 in\n   preference to IPv4 when the two are equally suitable.  An\n   administrator can change the policy table to prefer IPv4 addresses by\n   giving the ::ffff:0.0.0.0/96 prefix a higher precedence:\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      ::/0                  40     1\n      ::ffff:0:0/96        100     4\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n   This change to the default policy table produces the following\n   behavior:\n\n   Candidate Source Addresses: 2001:db8::2 or fe80::1 or 169.254.13.78\n   Destination Address List: 2001:db8::1 or 198.51.100.121\n   Unchanged Result: 2001:db8::1 (src 2001:db8::2) then 198.51.100.121\n   (src 169.254.13.78) (prefer matching scope)\n\n\n\nThaler, et al.               Standards Track                   [Page 20]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Candidate Source Addresses: fe80::1 or 198.51.100.117\n   Destination Address List: 2001:db8::1 or 198.51.100.121\n   Unchanged Result: 198.51.100.121 (src 198.51.100.117) then\n   2001:db8::1 (src fe80::1) (prefer matching scope)\n\n   Candidate Source Addresses: 2001:db8::2 or fe80::1 or 10.1.2.4\n   Destination Address List: 2001:db8::1 or 10.1.2.3\n   New Result: 10.1.2.3 (src 10.1.2.4) then 2001:db8::1 (src\n   2001:db8::2) (prefer higher precedence)\n\n10.3.1.  Handling Broken IPv6\n\n   One problem in practice that has been recently observed occurs when a\n   host has IPv4 connectivity to the Internet but has "broken" IPv6\n   connectivity to the Internet in that it has a global IPv6 address but\n   is disconnected from the IPv6 Internet.  Since the default policy\n   table prefers IPv6, this can result in unwanted timeouts.\n\n   This can be solved by configuring the table to prefer IPv4 as shown\n   above.  An implementation that has some means to detect that it is\n   not connected to the IPv6 Internet MAY do this automatically.  An\n   implementation could instead treat it as part of its implementation\n   of Rule 1 (avoid unusable destinations).\n\n10.4.  Configuring Preference for Link-Local Addresses\n\n   The destination address selection rules give preference to\n   destinations of smaller scope.  For example, a link-local destination\n   will be sorted before a global scope destination when the two are\n   otherwise equally suitable.  An administrator can change the policy\n   table to reverse this preference and sort global destinations before\n   link-local destinations:\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      ::/0                  40     1\n      ::ffff:0:0/96         35     4\n      fe80::/10             33     1\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 21]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   This change to the default policy table produces the following\n   behavior:\n\n   Candidate Source Addresses: 2001:db8::2 or fe80::2\n   Destination Address List: 2001:db8::1 or fe80::1\n   New Result: 2001:db8::1 (src 2001:db8::2) then fe80::1 (src fe80::2)\n   (prefer higher precedence)\n\n   Candidate Source Addresses: 2001:db8::2 (deprecated) or fe80::2\n   Destination Address List: 2001:db8::1 or fe80::1\n   Unchanged Result: fe80::1 (src fe80::2) then 2001:db8::1 (src 2001:\n   db8::2) (avoid deprecated addresses)\n\n10.5.  Configuring a Multi-Homed Site\n\n   Consider a site A that has a business-critical relationship with\n   another site B.  To support their business needs, the two sites have\n   contracted for service with a special high-performance ISP.  This is\n   in addition to the normal Internet connection that both sites have\n   with different ISPs.  The high-performance ISP is expensive, and the\n   two sites wish to use it only for their business-critical traffic\n   with each other.\n\n   Each site has two global prefixes, one from the high-performance ISP\n   and one from their normal ISP.  Site A has prefix 2001:db8:1aaa::/48\n   from the high-performance ISP and prefix 2001:db8:70aa::/48 from its\n   normal ISP.  Site B has prefix 2001:db8:1bbb::/48 from the high-\n   performance ISP and prefix 2001:db8:70bb::/48 from its normal ISP.\n   All hosts in both sites register two addresses in the DNS.\n\n   The routing within both sites directs most traffic to the egress to\n   the normal ISP, but the routing directs traffic sent to the other\n   site\'s 2001 prefix to the egress to the high-performance ISP.  To\n   prevent unintended use of their high-performance ISP connection, the\n   two sites implement ingress filtering to discard traffic entering\n   from the high-performance ISP that is not from the other site.\n\n   The default policy table and address selection rules produce the\n   following behavior:\n\n   Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or\n   fe80::a\n   Destination Address List: 2001:db8:1bbb::b or 2001:db8:70bb::b\n   Result: 2001:db8:70bb::b (src 2001:db8:70aa::a) then 2001:db8:1bbb::b\n   (src 2001:db8:1aaa::a) (longest matching prefix)\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 22]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   In other words, when a host in site A initiates a connection to a\n   host in site B, the traffic does not take advantage of their\n   connections to the high-performance ISP.  This is not their desired\n   behavior.\n\n   Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or\n   fe80::a\n   Destination Address List: 2001:db8:1ccc::c or 2001:db8:6ccc::c\n   Result: 2001:db8:1ccc::c (src 2001:db8:1aaa::a) then 2001:db8:6ccc::c\n   (src 2001:db8:70aa::a) (longest matching prefix)\n\n   In other words, when a host in site A initiates a connection to a\n   host in some other site C, the reverse traffic might come back\n   through the high-performance ISP.  Again, this is not their desired\n   behavior.\n\n   This predicament demonstrates the limitations of the longest-\n   matching-prefix heuristic in multi-homed situations.\n\n   However, the administrators of sites A and B can achieve their\n   desired behavior via policy table configuration.  For example, they\n   can use the following policy table:\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      2001:db8:1aaa::/48    43     6\n      2001:db8:1bbb::/48    43     6\n      ::/0                  40     1\n      ::ffff:0:0/96         35     4\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n   This policy table produces the following behavior:\n\n   Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or\n   fe80::a\n   Destination Address List: 2001:db8:1bbb::b or 2001:db8:70bb::b\n   New Result: 2001:db8:1bbb::b (src 2001:db8:1aaa::a) then 2001:db8:\n   70bb::b (src 2001:db8:70aa::a) (prefer higher precedence)\n\n   In other words, when a host in site A initiates a connection to a\n   host in site B, the traffic uses the high-performance ISP as desired.\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 23]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Candidate Source Addresses: 2001:db8:1aaa::a or 2001:db8:70aa::a or\n   fe80::a\n   Destination Address List: 2001:db8:1ccc::c or 2001:db8:6ccc::c\n   New Result: 2001:db8:6ccc::c (src 2001:db8:70aa::a) then 2001:db8:\n   1ccc::c (src 2001:db8:70aa::a) (longest matching prefix)\n\n   In other words, when a host in site A initiates a connection to a\n   host in some other site C, the traffic uses the normal ISP as\n   desired.\n\n10.6.  Configuring ULA Preference\n\n   Sections 2.1.4, 2.2.2, and 2.2.3 of RFC 5220 [RFC5220] describe\n   address selection problems related to Unique Local Addresses (ULAs)\n   [RFC4193].  By default, global IPv6 destinations are preferred over\n   ULA destinations, since an arbitrary ULA is not necessarily\n   reachable:\n\n   Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1\n   Destination Address List: 2001:db8:2::2 or fd22:2222:2222:2::2\n   Result: 2001:db8:2::2 (src 2001:db8:1::1) then fd22:2222:2222:2::2\n   (src fd11:1111:1111:1::1) (prefer higher precedence)\n\n   However, a site-specific policy entry can be used to cause ULAs\n   within a site to be preferred over global addresses as follows.\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      fd11:1111:1111::/48   45    14\n      ::/0                  40     1\n      ::ffff:0:0/96         35     4\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n   Such a configuration would have the following effect:\n\n   Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1\n   Destination Address List: 2001:db8:2::2 or fd22:2222:2222:2::2\n   Unchanged Result: 2001:db8:2::2 (src 2001:db8:1::1) then fd22:2222:\n   2222:2::2 (src fd11:1111:1111:1::1) (prefer higher precedence)\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 24]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1\n   Destination Address List: 2001:db8:2::2 or fd11:1111:1111:2::2\n   New Result: fd11:1111:1111:2::2 (src fd11:1111:1111:1::1) then 2001:\n   db8:2::2 (src 2001:db8:1::1) (prefer higher precedence)\n\n   Since ULAs are defined to have a /48 site prefix, an implementation\n   might choose to add such a row automatically on a machine with a ULA.\n\n   It is also worth noting that ULAs are assigned global scope.  As\n   such, the existence of one or more rows in the prefix policy table is\n   important so that source address selection does not choose a ULA\n   purely based on longest match:\n\n   Candidate Source Addresses: 2001:db8:1::1 or fd11:1111:1111:1::1\n   Destination Address List: ff00:1\n   Result: 2001:db8:1::1 (prefer matching label)\n\n10.7.  Configuring 6to4 Preference\n\n   By default, NATed IPv4 is preferred over 6to4-relayed connectivity:\n\n   Candidate Source Addresses: 2002:c633:6401::2 or 10.1.2.3\n   Destination Address List: 2001:db8:1::1 or 203.0.113.1\n   Result: 203.0.113.1 (src 10.1.2.3) then 2001:db8:1::1 (src 2002:c633:\n   6401::2) (prefer matching label)\n\n   However, NATed IPv4 is now also preferred over 6to4-to-6to4\n   connectivity by default.  Since a 6to4 prefix might be used natively\n   within an organization, a site-specific policy entry can be used to\n   cause native IPv6 communication (using a 6to4 prefix) to be preferred\n   over NATed IPv4 as follows.\n\n      Prefix        Precedence Label\n      ::1/128               50     0\n      2002:c633:6401::/48   45    14\n      ::/0                  40     1\n      ::ffff:0:0/96         35     4\n      2002::/16             30     2\n      2001::/32              5     5\n      fc00::/7               3    13\n      ::/96                  1     3\n      fec0::/10              1    11\n      3ffe::/16              1    12\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 25]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Such a configuration would have the following effect:\n\n   Candidate Source Addresses: 2002:c633:6401:1::1 or 10.1.2.3\n   Destination Address List: 2002:c633:6401:2::2 or 203.0.113.1\n   New Result: 2002:c633:6401:2::2 (src 2002:c633:6401:1::1) then\n   203.0.113.1 (sec 10.1.2.3) (prefer higher precedence)\n\n   Since 6to4 addresses are defined to have a /48 site prefix, an\n   implementation might choose to add such a row automatically on a\n   machine with a native IPv6 address with a 6to4 prefix.\n\n11.  References\n\n11.1.  Normative References\n\n   [RFC2119]       Bradner, S., "Key words for use in RFCs to Indicate\n                   Requirement Levels", BCP 14, RFC 2119, March 1997.\n\n   [RFC3056]       Carpenter, B. and K. Moore, "Connection of IPv6\n                   Domains via IPv4 Clouds", RFC 3056, February 2001.\n\n   [RFC3879]       Huitema, C. and B. Carpenter, "Deprecating Site Local\n                   Addresses", RFC 3879, September 2004.\n\n   [RFC4193]       Hinden, R. and B. Haberman, "Unique Local IPv6\n                   Unicast Addresses", RFC 4193, October 2005.\n\n   [RFC4291]       Hinden, R. and S. Deering, "IP Version 6 Addressing\n                   Architecture", RFC 4291, February 2006.\n\n   [RFC4380]       Huitema, C., "Teredo: Tunneling IPv6 over UDP through\n                   Network Address Translations (NATs)", RFC 4380,\n                   February 2006.\n\n   [RFC4862]       Thomson, S., Narten, T., and T. Jinmei, "IPv6\n                   Stateless Address Autoconfiguration", RFC 4862,\n                   September 2007.\n\n   [RFC4941]       Narten, T., Draves, R., and S. Krishnan, "Privacy\n                   Extensions for Stateless Address Autoconfiguration in\n                   IPv6", RFC 4941, September 2007.\n\n   [RFC6145]       Li, X., Bao, C., and F. Baker, "IP/ICMP Translation\n                   Algorithm", RFC 6145, April 2011.\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 26]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n11.2.  Informative References\n\n   [ADDR-SEL-OPT]  Matsumoto, A., Fujisaki, T., Kato, J., and T. Chown,\n                   "Distributing Address Selection Policy using DHCPv6",\n                   Work in Progress, August 2012.\n\n   [RFC1794]       Brisco, T., "DNS Support for Load Balancing",\n                   RFC 1794, April 1995.\n\n   [RFC1812]       Baker, F., "Requirements for IP Version 4 Routers",\n                   RFC 1812, June 1995.\n\n   [RFC1918]       Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot,\n                   G., and E. Lear, "Address Allocation for Private\n                   Internets", BCP 5, RFC 1918, February 1996.\n\n   [RFC2827]       Ferguson, P. and D. Senie, "Network Ingress\n                   Filtering: Defeating Denial of Service Attacks which\n                   employ IP Source Address Spoofing", BCP 38, RFC 2827,\n                   May 2000.\n\n   [RFC3484]       Draves, R., "Default Address Selection for Internet\n                   Protocol version 6 (IPv6)", RFC 3484, February 2003.\n\n   [RFC3493]       Gilligan, R., Thomson, S., Bound, J., McCann, J., and\n                   W. Stevens, "Basic Socket Interface Extensions for\n                   IPv6", RFC 3493, February 2003.\n\n   [RFC3701]       Fink, R. and R. Hinden, "6bone (IPv6 Testing Address\n                   Allocation) Phaseout", RFC 3701, March 2004.\n\n   [RFC3927]       Cheshire, S., Aboba, B., and E. Guttman, "Dynamic\n                   Configuration of IPv4 Link-Local Addresses",\n                   RFC 3927, May 2005.\n\n   [RFC4007]       Deering, S., Haberman, B., Jinmei, T., Nordmark, E.,\n                   and B. Zill, "IPv6 Scoped Address Architecture",\n                   RFC 4007, March 2005.\n\n   [RFC4191]       Draves, R. and D. Thaler, "Default Router Preferences\n                   and More-Specific Routes", RFC 4191, November 2005.\n\n   [RFC4213]       Nordmark, E. and R. Gilligan, "Basic Transition\n                   Mechanisms for IPv6 Hosts and Routers", RFC 4213,\n                   October 2005.\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 27]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   [RFC4861]       Narten, T., Nordmark, E., Simpson, W., and H.\n                   Soliman, "Neighbor Discovery for IP version 6\n                   (IPv6)", RFC 4861, September 2007.\n\n   [RFC5014]       Nordmark, E., Chakrabarti, S., and J. Laganier, "IPv6\n                   Socket API for Source Address Selection", RFC 5014,\n                   September 2007.\n\n   [RFC5214]       Templin, F., Gleeson, T., and D. Thaler, "Intra-Site\n                   Automatic Tunnel Addressing Protocol (ISATAP)",\n                   RFC 5214, March 2008.\n\n   [RFC5220]       Matsumoto, A., Fujisaki, T., Hiromi, R., and K.\n                   Kanayama, "Problem Statement for Default Address\n                   Selection in Multi-Prefix Environments: Operational\n                   Issues of RFC 3484 Default Rules", RFC 5220,\n                   July 2008.\n\n   [RFC5969]       Townsley, W. and O. Troan, "IPv6 Rapid Deployment on\n                   IPv4 Infrastructures (6rd) -- Protocol\n                   Specification", RFC 5969, August 2010.\n\n   [RFC6275]       Perkins, C., Johnson, D., and J. Arkko, "Mobility\n                   Support in IPv6", RFC 6275, July 2011.\n\n   [RFC6598]       Weil, J., Kuarsingh, V., Donley, C., Liljenstolpe,\n                   C., and M. Azinger, "IANA-Reserved IPv4 Prefix for\n                   Shared Address Space", BCP 153, RFC 6598, April 2012.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 28]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\nAppendix A.  Acknowledgements\n\n   RFC 3484 [RFC3484] acknowledged the contributions of the IPng Working\n   Group, particularly Marc Blanchet, Brian Carpenter, Matt Crawford,\n   Alain Durand, Steve Deering, Robert Elz, Jun-ichiro itojun Hagino,\n   Tony Hain, M.T. Hollinger, JINMEI Tatuya, Thomas Narten, Erik\n   Nordmark, Ken Powell, Markku Savela, Pekka Savola, Hesham Soliman,\n   Dave Thaler, Mauro Tortonesi, Ole Troan, and Stig Venaas.  In\n   addition, the anonymous IESG reviewers had many great comments and\n   suggestions for clarification.\n\n   This revision was heavily influenced by the work by Arifumi\n   Matsumoto, Jun-ya Kato, and Tomohiro Fujisaki in a working document\n   that made proposals for this revision to adopt, with input from Pekka\n   Savola, Remi Denis-Courmont, Francois-Xavier Le Bail, and the 6man\n   Working Group.  Dmitry Anipko, Mark Andrews, Ray Hunter, and Wes\n   George also provided valuable feedback on this revision.\n\nAppendix B.  Changes since RFC 3484\n\n   Some changes were made to the default policy table that were deemed\n   to be universally useful and cause no harm in every reasonable\n   network environment.  In doing so, care was taken to use the same\n   preference and label values as in RFC 3484 whenever possible and for\n   new rows to use label values less likely to collide with values that\n   might already be in use in additional rows on some hosts.  These\n   changes are:\n\n   1.  Added the Teredo [RFC4380] prefix (2001::/32), with the\n       preference and label values already widely used in popular\n       implementations.\n\n   2.  Added a row for ULAs (fc00::/7) below native IPv6 since they are\n       not globally reachable, as discussed in Section 10.6.\n\n   3.  Added a row for site-local addresses (fec0::/10) in order to\n       depreference them, for consistency with the example in\n       Section 10.3, since they are deprecated [RFC3879].\n\n   4.  Depreferenced 6to4 (2002::/32) below native IPv4 since 6to4\n       connectivity is less reliable today (and is expected to be phased\n       out over time, rather than becoming more reliable).  It remains\n       above Teredo since 6to4 is more efficient in terms of connection\n       establishment time, bandwidth, and server load.\n\n   5.  Depreferenced IPv4-Compatible addresses (::/96) since they are\n       now deprecated [RFC4291] and not in common use.\n\n\n\n\nThaler, et al.               Standards Track                   [Page 29]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   6.  Added a row for 6bone testing addresses (3ffe::/16) in order to\n       depreference them as they have also been phased out [RFC3701].\n\n   7.  Added optional ability for an implementation to add automatic\n       rows to the table for site-specific ULA prefixes and site-\n       specific native 6to4 prefixes.\n\n   Similarly, some changes were made to the rules, as follows:\n\n   1.  Changed the definition of CommonPrefixLen() to only compare bits\n       up to the source address\'s prefix length.  The previous\n       definition used the entire source address, rather than only its\n       prefix.  As a result, when a source and destination addresses had\n       the same prefix, common bits in the interface ID would previously\n       result in overriding DNS load balancing [RFC1794] by forcing the\n       destination address with the most bits in common to be always\n       chosen.  The updated definition allows DNS load balancing to\n       continue to be used as a tie breaker.\n\n   2.  Added Rule 5.5 to allow choosing a source address from a prefix\n       advertised by the chosen next-hop for a given destination.  This\n       allows better connectivity in the presence of BCP 38 [RFC2827]\n       ingress filtering and egress filtering.  Previously, RFC 3484 had\n       issues with multiple egress networks reached via the same\n       interface, as discussed in [RFC5220].\n\n   3.  Removed restriction against anycast addresses in the candidate\n       set of source addresses, since the restriction against using IPv6\n       anycast addresses as source addresses was removed in Section 2.6\n       of RFC 4291 [RFC4291].\n\n   4.  Changed mapping of RFC 1918 [RFC1918] addresses to global scope\n       in Section 3.2.  Previously, they were mapped to site-local\n       scope.  However, experience has resulted in current\n       implementations already using global scope instead.  When they\n       were mapped to site-local, Destination Address Selection Rule 2\n       (Prefer matching scope) would cause IPv6 to be preferred in\n       scenarios such as that described in Section 10.7.  The change to\n       global scope allows configurability via the prefix policy table.\n\n   5.  Changed the default recommendation for Source Address Selection\n       Rule 7 to prefer temporary addresses rather than public\n       addresses, while providing an administrative override (in\n       addition to the application-specific override that was already\n       specified).  This change was made because of the increasing\n       importance of privacy considerations, as well as the fact that\n       widely deployed implementations have preferred temporary\n       addresses for many years without major application issues.\n\n\n\nThaler, et al.               Standards Track                   [Page 30]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\n   Finally, some editorial changes were made, including:\n\n   1.  Changed global IP addresses in examples to use ranges reserved\n       for documentation.\n\n   2.  Added additional examples in Sections 10.6 and 10.7.\n\n   3.  Added Section 10.3.1 on "broken" IPv6.\n\n   4.  Updated references.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 31]\n\f\nRFC 6724           Default Address Selection for IPv6     September 2012\n\n\nAuthors\' Addresses\n\n   Dave Thaler (editor)\n   Microsoft\n   One Microsoft Way\n   Redmond, WA  98052\n   USA\n\n   Phone: +1 425 703 8835\n   EMail: dthaler@microsoft.com\n\n\n   Richard Draves\n   Microsoft Research\n   One Microsoft Way\n   Redmond, WA  98052\n   USA\n\n   Phone: +1 425 706 2268\n   EMail: richdr@microsoft.com\n\n\n   Arifumi Matsumoto\n   NTT SI Lab\n   Midori-Cho 3-9-11\n   Musashino-shi, Tokyo  180-8585\n   Japan\n\n   Phone: +81 422 59 3334\n   EMail: arifumi@nttv6.net\n\n\n   Tim Chown\n   University of Southampt on\n   Southampton, Hampshire  SO17 1BJ\n   United Kingdom\n\n   EMail: tjc@ecs.soton.ac.uk\n\n\n\n\n\n\n\n\n\n\n\n\n\nThaler, et al.               Standards Track                   [Page 32]\n\f';

    strPointCloud('RFC 6724', rfc);
  </script>
</body>
</html>
